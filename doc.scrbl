#lang scribble/manual
@(require racket/port racket/runtime-path scribble/example
          (for-syntax racket/base)
          (for-label racket (except-in haiku-enum
                                       #%top
                                       #%top-interaction
                                       #%module-begin)))
@(define-runtime-path very-simple-haiku.rkt '(lib "very-simple-haiku.rkt" "haiku-enum"))
@(define ev (make-base-eval))
@(ev `(require haiku-enum/very-simple-haiku))
@(define haiku-ev (make-base-eval))
@(haiku-ev `(require haiku-enum/haiku))

@title{Enumerating Haiku}

@defmodule[haiku-enum #:lang]{Programs written in the
 @racketmodname[haiku-enum] language define an enumeration of
 Haiku use the same concrete syntax as for Scribble
 (described in
 @secref["reader" #:doc '(lib "scribblings/scribble/scribble.scrbl")]),
 except starting in normal racket mode instead of starting in
 text mode.

 The haiku generated by a program in
 @racketmodname[haiku-enum] follow the rules and the
 vocabulary specified in the program. Rules are defined in
 two parts: a use of @racket[starters] that indicates how the
 haiku begin and then a series of uses of @racket[rule] that
 determine how the haiku continue (and end).

 The vocabulary is specified at the end of the file, using the
 parts of speech introduced by the rules.

 For example, consider this simple program in @racketmodname[haiku-enum]
 that has a set of rules that generate some especially boring Haiku:
 @typeset-code[#:context #'here
               (let ([sp (open-output-string)])
                 (call-with-input-file very-simple-haiku.rkt
                   (Î» (port) (copy-port port sp)))
                 (get-output-string sp))]

 The @racket[starters] part of the program declares that the
 Haiku must all begin with an adjective and then transition
 to the noun state (multiple possible starting parts of
 speech are allowed; just parenthesize each possibility).

 The rules describe the valid states. When in the @tt{noun}
 state, the language will generate a noun and then transition
 to the @tt{verb} state, as declared just below the
 @racket[starters] section in the first @racket[rule].
 Similarly, a @tt{verb} must be followed by a comma and then
 an adjective, and the cycle continues.

 After all of the rules, the vocabulary is declared. Each
 vocabulary declaration consists of the number of syllables,
 followed by words that are in that category of the part of
 speech and have that many syllables. Use one declaration for
 each different number of syllables that words in the part of
 speech may have.

 This file then provides:
 @itemlist[            
 @item{@tt{random-haiku}: a function that accepts no
   arguments and returns a random haiku (as a string),}
   @item{@tt{how-many-haiku}:, a natural number that indicates
   how many different haiku this program generates,}
 @item{@tt{nth-haiku}: a function that accepts a natural
   number less than @tt{how-many-haiku} and returns the
   corresponding haiku, and}
 @item{@tt{enum/e}: a
   @tech[#:doc '(lib "data/scribblings/data.scrbl")]{one-way
    enumeration} of the same haiku that @tt{nth-haiku} returns}
 @item{@tt{structured-haiku/e}: a
   @tech[#:doc '(lib "data/scribblings/data.scrbl")]{two-way
    enumeration} that maps the naturals to an sexpression
   representing the choices made to construct a particular
   haiku}]

 @examples[#:eval ev
           (display (nth-haiku 0))
           (display (nth-haiku (- how-many-haiku 1)))
           (display (nth-haiku (quotient (- how-many-haiku 1) 2)))]

 The library also contains the file @filepath{haiku.rkt}, a more
 elaborate example that contains haiku such as these:
  @examples[#:eval haiku-ev #:label #f
           (display (nth-haiku 145095608713658901635917363016718021515))
           (display (nth-haiku 5842574289046493184639147839447824095))]
  The @filepath{haiku.rkt} program is a reimplementation of the program
  that generates random haiku from @url{http://www.everypoet.com/haiku/}.

}

@defform*[[(rule haiku-state-id word-class-id -> next-state ...)
           (rule haiku-state-id -> next-state ...)]
         #:grammar ([next-state
                     (code:line maybe-lastness maybe-comma haiku-state-id)]
                    [maybe-lastness
                     (code:line)
                     #:only-last
                     #:not-last]
                    [maybe-comma
                     (code:line)
                     #:comma])]{
 Defines a state for haiku named @racket[haiku-state-id] that, when entered,
 generates a word from @racket[word-class-id] and then
 transitions to one of the states listed in @racket[next-state]. If
 @racket[word-class-id] does not appear, then @racket[haiku-state-id]
 is taken as both the name of the state and the name of the class of
 words to generate.

 If @racket[#:only-last] appears, then this state is entered
 only when it would be the last word in the haiku. If
 @racket[#:not-last] appears, then this state is entered
 only when it would not be the last word in the haiku.

 If @racket[#:comma] appears, then a comma is generated in the haiku before
 continuing into the next state.

 In addition to defining a new rule, a use of @racket[rule]
 defines @racket[word-class-id] (if the first case is used)
 or @racket[haiku-state-id] (if the second case is used). It
 is defined to accept a natural number and a sequence of
 strings that are assumed to be words that all have the given
 number of syllables. The name can be used multiple times
 with different numbers of syllables.

 For example, the rule
 @racketblock[(rule adjective -> noun)] generates a rule that
 transitions from the adjective state to the noun state and
 admits the possibility of defining adjectives by using
 @racket[adjective], e.g.,
 @racketblock[(adjective 1 "tall" "fast")
              (adjective 2 "three-point" "driven")
              (adjective 3 "athletic")]
 Use underscores in the word if it should be rendered with
 a space but count as a single item in a haiku (i.e., it should
 either appear entirely or not at all), e.g.:
 @racketblock[(noun 4 "Michael_Jordan")]
 which appears as @racket["Michael Jordan"] but never
 @racket["Michael"] or @racket["Jordan"] on their own.
}

@defform[(starters (word-class-id haiku-state-id) ...)]{
 Starts a haiku.

 Each clause indicates one way that a haiku can start, namely
 by generating a word from @racket[word-class-id] and then
 moving into the state @racket[haiku-state-id].
}
